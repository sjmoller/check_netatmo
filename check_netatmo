#!/usr/bin/perl
#
# Netatmo Weatherstation healthcheck Nagios plugin
# Version 0.2
#
# 1) Create your client_id and client_secret at https://dev.netatmo.com.
#
# 2) Place this JSON data in /usr/local/etc/netatmo.conf:
# {
#   "client_id" : "your-client_id-here",
#   "client_secret" : "your-client_secret-here",
#   "username" : "your-netatmo-username-here",
#   "password" : "your-netatmo-password-here"
# }
#
# 3) See your data arrive in $HOME/var/netatmo. $HOME is the home of the user running this plugin.
#
# 180822: 0.1: Intial version
# 180822: 0.2: Use Nagios::Plugin to parse arguments. All values can now be tested.
#
# Soren Juul Moller, Aug 2018

use strict;
use warnings;
use Nagios::Plugin;
use Fcntl qw(:flock);
use File::Path qw(make_path);
use Sys::Syslog;
use JSON;
use LWP::UserAgent;
use DateTime::Format::DateParse;
use lib '/opt/plugins';
use utils qw($TIMEOUT);

my $PROGNAME = "check_netatmo";
my $VERSION = "0.2";
my $API = "https://api.netatmo.net";
my $CONFFILE = '/usr/local/etc/netatmo.conf';
my $RUN = "$ENV{HOME}/var/netatmo";
my $CACHE_TTL = 600;	# 10 min data cache
my $LOCK;

##############################################################################

my $np = Nagios::Plugin->new(
	usage => 'Usage: %s -a attr [-w INT:INT -c INT:INT -T -e equal-str -n not-equal-str -p perfdata -m message-template]',
	version => $VERSION,
	blurb => 'Netatmo check',
	extra => "Examples:\n" .
		 "   $PROGNAME -a '{body}->{devices}[0]->{dashboard_data}->{Temperature}' -w28: -c32: -p '28:32:28:32'    (Indoor temperature)\n" .
		 "   $PROGNAME -a '{body}->{devices}[0]->{modules}[0]->{last_seen}' -T -w:3600 -c:7200 -m 'Outdoor seen %t ago'   (Outdoor timestamp)\n" .
		 "   $PROGNAME -a '{body}->{devices}[0]->{modules}[2]->{dashboard_data}->{WindAngle}' -w\@220:280 -c\@280:330  (wind angle)\n".
		 "   $PROGNAME -a '{body}->{status}' -e ok\n" .
		 "see also https://nagios-plugins.org/doc/guidelines.html#THRESHOLDFORMAT",
	url => 'https://github.com/sjmoller/check_netatmo',
	plugin => $PROGNAME,
	timeout => 15,
	shortname => 'Netatmo'
);
$np->add_arg(
	spec => 'attribute|a=s',
	help => "-a, --attribute {attr}->{attr}",
	required => 1
);
$np->add_arg(
	spec => 'warning|w=s',
	help => '-w, --warning INT:INT',
);
$np->add_arg(
	spec => 'critical|c=s',
	help => '-c, --critical INT:INT',
);
$np->add_arg(
	spec => 'timestamp|T',
	help => "-T, --timestamp\n" .
		"   value is an epoch. Compare to epoch now (diff in seconds)"
);
$np->add_arg(
	spec => 'equal|e=s',
	help => '-e, --equals str' .
		"\n   critical if not equal"
);
$np->add_arg(
	spec => 'notequal|n=s',
	help => '-n, --notequals str' .
		"\n   critical if equal"
);
$np->add_arg(
	spec => 'perfdata|p:s',
	help => "-p, --perfdata [thresholds]\n" .
		"   Nagios performance data format: name=value[:warnlevel[:critlevel[:min[:max]]]]".
		"   Format defaults to \"label=value\"\n" .
		"   threshols:  warn[;crit[;min[;max]]] - example: -p '25:50:25:50'"
);
$np->add_arg(
	spec => 'message|m=s',
	help => "-m, --message message-template\n" .
		"   Format: 'Value %a is %v' or 'device seen %t ago'\n" .
		"   where %a is attribute name, %v is value and %t is duration"
);
$np->getopts;

##############################################################################

sub prettytime($) {
  my $secs = shift;
  my ($ss,$mi,$hh,$dd,$mm,$yy,@rest) = gmtime($secs);
  $dd--;
  return "${dd}d ${hh}h ${mi}m" if $dd > 0;
  return "${hh}h ${mi}m ${ss}s" if $hh > 0;
  return "${mi}m ${ss}s" if $mi > 0;
  return "${ss}s";
}

sub exit_state($$) {
  my ($state, $txt) = @_;
  flock($LOCK, LOCK_UN) if defined $LOCK;
  print qw(OK WARNING CRITICAL UNKNOWN)[$state] . " - $txt\n";
  closelog();
  exit $state;
}

sub exit_error($) {
  my $txt = shift;
  syslog('err', $txt);
  exit_state(UNKNOWN, $txt);
}

sub load_json($) {
  my $file = shift;
  local $/;  # enable slurp
  open(my $fh, '<', $file) || exit_error("$file read error: $!");
  my $json = <$fh>;
  close($fh);
  return from_json($json);
}

sub store_json($$) {
  my ($file, $hashref) = @_;
  open(my $fh, '>', $file) || exit_error("cannot create $file: $!");
  print $fh to_json($hashref, { utf8 => 1, pretty => 1 });
  close($fh);
}

sub load_conf() {
  my $conf = load_json($CONFFILE);
  foreach (qw(client_id client_secret username password)) {
    exit_error("$_ not defined in $CONFFILE") unless defined $conf->{$_};
  }
  return $conf;
}

sub get_token {
  my $ua = LWP::UserAgent->new(agent => "$PROGNAME/$VERSION");
  my $now = DateTime->now();
  my $content;
  my $dirty = 0;
  my $conf;

  if (-s "$RUN/token.json") {
    # Got a cache file, refresh login
    my $store = load_json("$RUN/token.json");
    my $lastupdate = DateTime::Format::DateParse->parse_datetime($store->{token_last_updated}, 'UTC');
    my $delta = $now->epoch() - $lastupdate->epoch();
    if ($delta > ($store->{expires_in} - 900)) {
      # Refresh token
      $conf = load_conf();
      my $req = $ua->post(
          "$API/oauth2/token",
	  [
	    grant_type => 'refresh_token',
	    client_id => $conf->{client_id},
	    client_secret => $conf->{client_secret},
	    refresh_token => $store->{refresh_token}
	  ]
      );
      if (!$req->is_success) {
        syslog('warning', "failed to refresh oath2 token. Trying login.");
        goto Login;   # not nice, but handy :-)
      }
      syslog('info', "oauth2 token refreshed");
      $content = decode_json($req->decoded_content);
      $store->{access_token} = $content->{access_token};
      $store->{refresh_token} = $content->{refresh_token};
      $store->{token_last_updated} = $now->datetime();
      $dirty = 1;
    }
    $content = $store;
  } else {
    # No cache file or oauth2 refresh failed. Do login
    Login:
    $conf = load_conf() unless defined $conf;
    my $req = $ua->post(
	"$API/oauth2/token",
	[
	  grant_type => 'password',
	  client_id => $conf->{client_id},
	  client_secret => $conf->{client_secret},
	  username => $conf->{username},
	  password => $conf->{password},
	  scope => 'read_station'
	]
    );
    exit_error("Unable to login as ".$conf->{username}) unless $req->is_success;
    syslog('info', "new oauth2 token generated using grant_type password");
    $content = decode_json($req->decoded_content);
    $content->{token_last_updated} = $now->datetime();
    $dirty = 1;
  }

  # Update store if token was updated
  store_json("$RUN/token.json", $content) if $dirty;

  return $content;
}

sub getstationdata() {
  my $now = DateTime->now();
  my $content;
  my $needs_update = 0;

  if (-s "$RUN/data.json") {
    $content = load_json("$RUN/data.json");
    my $lastupdate = $content->{time_server};
    my $delta = $now->epoch() - $lastupdate;
    $needs_update = 1 if $delta > $CACHE_TTL;
  } else {
    $needs_update = 1;
  }

  if ($needs_update) {
    my $token = get_token();
    exit_error("Login failed") unless defined $token;
    my $ua = LWP::UserAgent->new(agent => "$PROGNAME/$VERSION");
    my $req = $ua->post("$API/api/getstationsdata", [ access_token => $token->{access_token} ]);
    exit_error("Data fetch failed: ".$req->status_line) unless $req->is_success;
    $content = decode_json($req->decoded_content);
    syslog('info', "$RUN/data.json fetched ok");
    store_json("$RUN/data.json", $content);
  }
  return $content;
}

##############################################################################

openlog('check_netatmo', 'nofatal', 'local0');

unless (-d $RUN) {
  exit_error("Cannot create $RUN: $!\n") if make_path($RUN, 0755) != 1;
}

# Just in case of problems, let's not hang Nagios
$SIG{'ALRM'} = sub {
  exit_error("ERROR: No response from $API (timeout)");
};
alarm($TIMEOUT);

# Exclusive access to getstationdata needed
open($LOCK, '<', $CONFFILE) || exit_error("Cannot open $CONFFILE");
flock($LOCK, LOCK_EX) || exit_error("Cannot lock $CONFFILE");

my $data = getstationdata();

# Release lock
flock($LOCK, LOCK_UN);
close($LOCK);
undef $LOCK;

alarm(0);

my $attr = $np->opts->attribute;

# remove dangerous characters before eval
$attr =~ tr/;()|\`\'\"\\/_/;

my $val;
eval '$val = $data->'.$attr;
exit_error("$attr not found") unless defined $val;

my $state = OK;
if ($np->opts->equal) {
  $state = CRITICAL if $val ne $np->opts->equal;
}
elsif ($np->opts->notequal) {
  $state = CRITICAL if $val eq $np->opts->notequal;
}
elsif ($np->opts->timestamp) {
  my $delta = DateTime->now()->epoch() - $val;
  $state = $np->check_threshold(
	check => $delta,
	warning => $np->opts->warning,
	critical => $np->opts->critical
  );
  $val = $delta;
}
else {
  $state = $np->check_threshold(
	check => $val,
	warning => $np->opts->warning,
	critical => $np->opts->critical,
  );
}

$attr =~ s/.*{([a-z0-9_]+)}$/$1/i;
my $str = "$attr $val";

if ($np->opts->message) {
  # Template specified. Use that instead.
  $str = $np->opts->message;
  $str =~ s/%a/$attr/g;
  $str =~ s/%v/$val/g;
  my $t = prettytime($val);
  $str =~ s/%t/$t/g;
}

# Add perfdata if requested
if (my $p = $np->opts->perfdata) {
  $str .= "|$attr=$val";
  if (length($p) > 0) {
    $p =~ s/:/;/g;
    $str .= ";$p";
  }
}

exit_state($state, $str);
